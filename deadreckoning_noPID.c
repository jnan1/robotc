#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Motor,  motorA,          left_motor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          right_motor,   tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float wheel_radius = 1.063;//inches
float turn_radius = 2.46;//inches

void goStraight(float distance)
{
	float angle_to_spin = distance/wheel_radius*180/PI;
	nMotorEncoder[left_motor] = 0;
	nMotorEncoder[right_motor] = 0;

	motor[left_motor] = 70;
	motor[right_motor] = 70;

	nMotorEncoderTarget[left_motor] = angle_to_spin;
	nMotorEncoderTarget[right_motor] = angle_to_spin;
	while (nMotorEncoder[left_motor] < angle_to_spin && nMotorEncoder[right_motor] < angle_to_spin){
		wait1Msec(5);
	}
	motor[left_motor] = 0;
	motor[right_motor] = 0;
}

void turn_in_place(float angle)
{
	float angle_to_spin = angle*turn_radius/wheel_radius;
	nMotorEncoder[left_motor] = 0;
	nMotorEncoder[right_motor] = 0;

	motor[left_motor] = 70;
	motor[right_motor] = 70;

	nMotorEncoderTarget[left_motor] = angle_to_spin;
	nMotorEncoderTarget[right_motor] = angle_to_spin;
	while (nMotorEncoder[left_motor] < angle_to_spin && nMotorEncoder[right_motor] < angle_to_spin){
		wait1Msec(5);
	}
	motor[left_motor] = 0;
	motor[right_motor] = 0;
}

task main()
{
	float distance1 = 10;
	float distance2 = 10;
	float angle1 = 90;
	float angle2 = -180;
	goStraight(distance1);
	turn_in_place(angle1);
	goStraight(distance2);
	turn_in_place(angle2);
}
