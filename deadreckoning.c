#pragma config(Motor,  motorB,          motorA,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorB,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
 * Lab 3 : Starter code
 * Written by Kaushik Viswanathan,
 * Modified by Allan Wang (Jan 2017)

 * Feel free to modify any part of these codes.
 **********************************************/

//Global variables - you will need to change some of these
//Robot's positions
float robot_X = 0.0, robot_Y = 0.0, robot_TH = 0.0;
float wheelradius = 1.1;
float robotWidth = 4.76;

int velocityUpdateInterval = 5;
int PIDUpdateInterval = 2;

//Change these during demo
int inputStraight[2] = {24, 36}; // in mm
int inputTurn[2] = {90, -180}; // in degrees, negative means clockwise rotation
int motorPower = 40;

/*****************************************
 * Complete this function so that it
 * continuously updates the robot's position
 *****************************************/
task dead_reckoning()
{

	while(1)
	{
		//
		// Fill in code for numerical integration / position estimation here
		//

		/*Code that plots the robot's current position and also prints it out as text*/
		nxtSetPixel(50 + (int)(100.0 * robot_X), 32 + (int)(100.0 * robot_Y));
		nxtDisplayTextLine(0, "X: %f", robot_X);
		nxtDisplayTextLine(1, "Y: %f", robot_Y);
		nxtDisplayTextLine(2, "th: %f", robot_TH);
		wait1Msec(velocityUpdateInterval);
	}
}

/*****************************************
 * Function that draws a grid on the LCD
 * for easier readout of whatever is plot
 *****************************************/
void draw_grid()
{
	for(int i = 0; i < 65; i++)
	{
		nxtSetPixel(50, i);
		int grid5 = (i - 32) % 5;
		int grid10 = (i - 32) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
	}
	for(int i = 0; i < 101; i++)
	{
		nxtSetPixel(i, 32);
		int grid5 = (i - 100) % 5;
		int grid10 = (i - 100) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
	}
}

/**********************************************
 * Function that judges if two floats are equal
 **********************************************/
 bool equal(float a, float b, float epsilon) {
   if (abs(a-b) < epsilon) {
     return true;
   } else {
     return false;
   }
 }


/*****************************************
 * Main function - Needs changing
 *****************************************/
task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorA] = 0;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	float start_X = 0;
	float start_Y = 0;
	float ref_TH = 0;
	draw_grid();
	startTask(dead_reckoning);
	clearTimer(T1);
	for(int i = 0; i < 2; i++)
	{
		float distTravelled = 0;
		float angleTurned = 0;
		int goalStraight = inputStraight[i];
		int goalTurn = inputTurn[i];
		nMotorEncoder[motorB] = 0;
		nMotorEncoder[motorA] = 0;
		//turning
		//float prevt = 0.0, prevl = 0.0, prevr = 0.0;
		//clearTimer(T1);
		while (!equal(angleTurned, goalTurn, 1)) {
			int sgn = goalTurn > 0 ? 1 : -1;
			motor[motorA] = motorPower / 3 * (-sgn);
			motor[motorB] = motorPower / 3 * sgn;
			angleTurned = nMotorEncoder[motorB] * wheelradius / robotWidth * 2;
			nxtDisplayTextLine(3, "sgn: %d", sgn);
		}
		robot_TH = robot_TH + angleTurned;
		ref_TH = ref_TH + goalTurn;
		motor[motorA] = 0;
		motor[motorB] = 0;
		wait1Msec(1000);
		//moving in a straight line
		nMotorEncoder[motorB] = 0;
		nMotorEncoder[motorA] = 0;
		float prevl = nMotorEncoder[motorA] * wheelradius * PI / 180;
		float prevr = nMotorEncoder[motorB] * wheelradius * PI / 180;
		float kp = 0.08;
		clearTimer(T1);
		float prevt = (float) time1[T1] / 1000;
		start_X = robot_X;
		start_Y = robot_Y;
		while (!equal(distTravelled, goalStraight, 1)) {
			float t = (float) time1[T1] / 1000;
			float dt = t - prevt;
			if(dt == 0) continue;
			prevt = t;
			float l = (float)nMotorEncoder[motorA] * wheelradius * PI / 180;
			float r = (float)nMotorEncoder[motorB] * wheelradius * PI / 180;
			float vl = (l - prevl) / dt;
			float vr = (r - prevr) / dt;
			float v = (vl + vr) / 2;
			float w = (vr - vl) / 2 * 180 / PI;
			prevl = l;
			prevr = r;
			robot_TH = robot_TH + w * dt / 2;
			robot_X = robot_X + cosDegrees(robot_TH) * v * dt;
			robot_Y = robot_Y + sinDegrees(robot_TH) * v * dt;
			robot_TH = robot_TH + w * dt / 2;
			float error = robot_TH - ref_TH;
			motor[motorA] = motorPower * (1 + kp * error);
			motor[motorB] = motorPower;
			distTravelled = sqrt(pow(robot_X-start_X, 2) + pow(robot_Y-start_Y, 2));
			nxtDisplayTextLine(3, "v: %f", v);
			wait1Msec(100);
		}

		motor[motorA] = 0;
		motor[motorB] = 0;

		wait1Msec(100 * 5);
	}
	motor[motorA] = 0;
	motor[motorB] = 0;
	nNxtButtonTask  = 0;
	while(nNxtButtonPressed != kExitButton) {}
}
